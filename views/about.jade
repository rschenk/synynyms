#about
  .container
    h1 about synynyms
    #author
      p Ryan Schenk made this application for the Life and Literature Code Challenge. Ryan does freelance data visualization, data processing, design, and development. If you'd like to chat, feel free to contact him via <a href="mailto:rschenk@gmail.com">email</a> or follow him on <a href="http://twitter.com/ryanschenk">Twitter</a>.
    #buzzwords
      p The backend of synonyms is written in <a href="http://nodejs.org">Node.js</a>. The graphs are rendered in realtime as the data arrives from the <abbr title="Biodiversity Heritage Library">BHL</abbr> <abbr title="Application Programming Interface">API</abbr>, thanks to <a href="http://socket.io/">Socket.io</a>. The client side uses <a href="http://documentcloud.github.com/backbone/">Backbone.js</a> to coordinate everything and <a href="http://raphaeljs.com/">Raphael</a> to render the blobby graphs.
    #attribution
      p The scientific names, synonyms, and pictures all come from the <a href="http://eol.org">Encyclopedia of Life</a>. We calculate the number of publications per year for each scientific name using the literature corpus provided by the <a href="http://biodiversitylibrary.org">Biodiversity Heritage Library</a>.
#nerdAlert
  .container
    h1 nerd alert!
    p You may have noticed that the graphs build themselves in realtime as the data streams back from the <abbr title="Biodiversity Heritage Library">BHL</abbr>. The traditional approach is to hit the web service from the server, wait for the entire response, then render out the graphs to the client. In synynyms, however, as each chunk of data is received by the server, it is immediately processed, and streamed to the client. This way, the user sees something quickly, even if the entire dataset takes a long time to arrive; the graph itself serves a bit like its own  progress bar.
    p Node.js was an obvious choice for a server architecture that would allow the highly asynchronous, event-driven system that this would require. Plus, the fantastic Socket.io library made the WebSocket implementation a no-brainer. I used Backbone.js to abstract the data streaming into the browser from its representation as a graph. Indeed, if Edward Tufte complains that my graphs are too blobby and don't contain a vertical scale, I can easily re-render them as sparkline datawords with annotated minima and maxima. But I like blobs!
    footer: img(src="/about-footer.png")